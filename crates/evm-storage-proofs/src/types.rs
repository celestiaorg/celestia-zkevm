use alloy_primitives::{
    Address, Bytes, FixedBytes,
    hex::{FromHex, ToHexExt},
};
use alloy_rpc_types::EIP1186AccountProofResponse;
use alloy_trie::{Nibbles, TrieAccount, proof::verify_proof};

use crate::digest_keccak;

pub const HYPERLANE_MERKLE_TREE_KEYS: [&str; 32] = [
    "0x0000000000000000000000000000000000000000000000000000000000000097",
    "0x0000000000000000000000000000000000000000000000000000000000000098",
    "0x0000000000000000000000000000000000000000000000000000000000000099",
    "0x000000000000000000000000000000000000000000000000000000000000009a",
    "0x000000000000000000000000000000000000000000000000000000000000009b",
    "0x000000000000000000000000000000000000000000000000000000000000009c",
    "0x000000000000000000000000000000000000000000000000000000000000009d",
    "0x000000000000000000000000000000000000000000000000000000000000009e",
    "0x000000000000000000000000000000000000000000000000000000000000009f",
    "0x00000000000000000000000000000000000000000000000000000000000000a0",
    "0x00000000000000000000000000000000000000000000000000000000000000a1",
    "0x00000000000000000000000000000000000000000000000000000000000000a2",
    "0x00000000000000000000000000000000000000000000000000000000000000a3",
    "0x00000000000000000000000000000000000000000000000000000000000000a4",
    "0x00000000000000000000000000000000000000000000000000000000000000a5",
    "0x00000000000000000000000000000000000000000000000000000000000000a6",
    "0x00000000000000000000000000000000000000000000000000000000000000a7",
    "0x00000000000000000000000000000000000000000000000000000000000000a8",
    "0x00000000000000000000000000000000000000000000000000000000000000a9",
    "0x00000000000000000000000000000000000000000000000000000000000000aa",
    "0x00000000000000000000000000000000000000000000000000000000000000ab",
    "0x00000000000000000000000000000000000000000000000000000000000000ac",
    "0x00000000000000000000000000000000000000000000000000000000000000ad",
    "0x00000000000000000000000000000000000000000000000000000000000000ae",
    "0x00000000000000000000000000000000000000000000000000000000000000af",
    "0x00000000000000000000000000000000000000000000000000000000000000b0",
    "0x00000000000000000000000000000000000000000000000000000000000000b1",
    "0x00000000000000000000000000000000000000000000000000000000000000b2",
    "0x00000000000000000000000000000000000000000000000000000000000000b3",
    "0x00000000000000000000000000000000000000000000000000000000000000b4",
    "0x00000000000000000000000000000000000000000000000000000000000000b5",
    "0x00000000000000000000000000000000000000000000000000000000000000b6",
];

pub struct HyperlaneBranchProof {
    pub proof: EIP1186AccountProofResponse,
}

impl HyperlaneBranchProof {
    pub fn new(proof: EIP1186AccountProofResponse) -> Self {
        Self { proof }
    }
    pub fn get_branch_node(&self) -> String {
        self.proof
            .storage_proof
            .first()
            .unwrap()
            .value
            .to_be_bytes::<32>()
            .encode_hex()
    }
    pub fn verify(&self, key: &str, contract: Address, root: String) -> bool {
        let leaf_node: Vec<Bytes> = alloy_rlp::decode_exact(&self.proof.account_proof.last().unwrap()).unwrap();
        let stored_account = leaf_node.last().unwrap().to_vec();
        // verify the account proof against the execution state root
        match verify_proof(
            FixedBytes::from_hex(root).unwrap(),
            Nibbles::unpack(&digest_keccak(&contract.0.0)),
            Some(stored_account.clone()),
            &self.proof.account_proof,
        ) {
            Ok(_) => {}
            Err(_) => return false,
        }
        let account: TrieAccount = alloy_rlp::decode_exact(&stored_account).unwrap();
        // must rlp encode the 32 byte value before verifying the proof
        let raw32 = self.proof.storage_proof.first().unwrap().value.to_be_bytes::<32>();
        let encoded: Vec<u8> = alloy_rlp::encode(raw32.as_slice());
        // verify the storage proof against the account root
        match verify_proof(
            account.storage_root,
            Nibbles::unpack(&digest_keccak(&alloy_primitives::hex::decode(key).unwrap())),
            Some(encoded),
            &self.proof.storage_proof.first().unwrap().proof,
        ) {
            Ok(_) => {}
            Err(_) => return false,
        }
        true
    }
}
