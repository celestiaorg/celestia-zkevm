use std::str::FromStr;

use alloy::{
    hex::FromHex,
    providers::{Provider, ProviderBuilder},
    rpc::types::EIP1186AccountProofResponse,
    transports::http::reqwest::Url,
};
use alloy_primitives::{Address, FixedBytes};
use anyhow::Result;

pub struct EvmClient {
    pub url: String,
}

impl EvmClient {
    pub fn new(url: String) -> Self {
        Self { url }
    }
    pub async fn get_proof(&self, key: &str, contract: Address, height: u64) -> Result<EIP1186AccountProofResponse> {
        let provider = ProviderBuilder::new().connect_http(Url::from_str(&self.url)?);
        let proof: EIP1186AccountProofResponse = provider
            .get_proof(contract, vec![FixedBytes::from_hex(key)?])
            .block_id(height.into())
            .await?;
        Ok(proof)
    }
}

#[cfg(test)]
mod tests {
    use crate::client::EvmClient;
    use alloy::hex::{FromHex, ToHexExt};
    use alloy_primitives::Address;

    /* Hyperlane Merkle Tree hook storage keys for a depth 32 tree
    0x0000000000000000000000000000000000000000000000000000000000000097 // idx 0
    0x0000000000000000000000000000000000000000000000000000000000000098
    0x0000000000000000000000000000000000000000000000000000000000000099
    0x000000000000000000000000000000000000000000000000000000000000009a
    0x000000000000000000000000000000000000000000000000000000000000009b
    0x000000000000000000000000000000000000000000000000000000000000009c
    0x000000000000000000000000000000000000000000000000000000000000009d
    0x000000000000000000000000000000000000000000000000000000000000009e
    0x000000000000000000000000000000000000000000000000000000000000009f
    0x00000000000000000000000000000000000000000000000000000000000000a0
    0x00000000000000000000000000000000000000000000000000000000000000a1
    0x00000000000000000000000000000000000000000000000000000000000000a2
    0x00000000000000000000000000000000000000000000000000000000000000a3
    0x00000000000000000000000000000000000000000000000000000000000000a4
    0x00000000000000000000000000000000000000000000000000000000000000a5
    0x00000000000000000000000000000000000000000000000000000000000000a6
    0x00000000000000000000000000000000000000000000000000000000000000a7
    0x00000000000000000000000000000000000000000000000000000000000000a8
    0x00000000000000000000000000000000000000000000000000000000000000a9
    0x00000000000000000000000000000000000000000000000000000000000000aa
    0x00000000000000000000000000000000000000000000000000000000000000ab
    0x00000000000000000000000000000000000000000000000000000000000000ac
    0x00000000000000000000000000000000000000000000000000000000000000ad
    0x00000000000000000000000000000000000000000000000000000000000000ae
    0x00000000000000000000000000000000000000000000000000000000000000af
    0x00000000000000000000000000000000000000000000000000000000000000b0
    0x00000000000000000000000000000000000000000000000000000000000000b1
    0x00000000000000000000000000000000000000000000000000000000000000b2
    0x00000000000000000000000000000000000000000000000000000000000000b3
    0x00000000000000000000000000000000000000000000000000000000000000b4
    0x00000000000000000000000000000000000000000000000000000000000000b5
    0x00000000000000000000000000000000000000000000000000000000000000b6 // idx 31

    0x00000000000000000000000000000000000000000000000000000000000000b7 count
    */

    #[tokio::test]
    async fn test_get_branch() {
        let contract = Address::from_hex("0xfcb1d485ef46344029d9e8a7925925e146b3430e").unwrap();
        let client = EvmClient::new("http://127.0.0.1:8545".to_string());
        let proof = client
            .get_proof(
                // starts at 151 up to 182, count is located at 183
                // get the first one to check against off-chain tree
                "0x0000000000000000000000000000000000000000000000000000000000000097",
                contract,
                200,
            )
            .await
            .unwrap();

        let value = proof
            .storage_proof
            .first()
            .unwrap()
            .value
            .to_be_bytes::<32>()
            .encode_hex();
        println!("value: {:?}", value);
    }
}
