// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{EV_EXEC_ELF, EV_EXEC_ID};
use risc0_zkvm::{default_prover, ExecutorEnv};
use std::env;
use std::error::Error;
use std::fs;

use alloy_primitives::FixedBytes;
use anyhow::Result;
use celestia_types::nmt::{Namespace, NamespaceProof};
use celestia_types::{Blob, DataAvailabilityHeader};
use clap::Parser;
use ev_zkevm_types::programs::block::{BlockExecInput, BlockExecOutput};
use rsp_client_executor::io::{EthClientExecutorInput, WitnessInput};
use tendermint::block::header::Header;

/// The arguments for the command.
#[derive(Parser, Debug)]
#[command(author, version = clap::crate_version!(), about = "A CLI for running the ev-exec SP1 program", long_about = None)]
struct Args {
    #[arg(long, help = "The Celestia block height")]
    height: u64,

    #[arg(long, help = "Output file for benchmark report in JSON format")]
    output_file: Option<String>,

    #[arg(long, help = "Trusted EVM height which contains trusted state root")]
    trusted_height: Option<u64>,

    #[arg(long, help = "Trusted state root (hex string) for the trusted height")]
    trusted_root: Option<String>,
}

fn main() -> Result<(), Box<dyn Error>> {
    dotenvy::dotenv().ok();
    let args = Args::parse();

    if args.height == 0 {
        eprintln!("Error: You must specify a block number using --height");
        std::process::exit(1);
    }

    let height = args.height;
    let input_dir = format!("testdata/inputs/block-{height}");

    let prover = default_prover();
    let input = get_proof_input(&input_dir, &args)?;
    let env = ExecutorEnv::builder().write(&input).unwrap().build().unwrap();

    let prove_info = prover.prove(env, EV_EXEC_ELF).unwrap();
    let receipt = prove_info.receipt;
    let _output: BlockExecOutput = receipt.journal.decode().unwrap();
    receipt.verify(EV_EXEC_ID).unwrap();

    Ok(())
}

fn get_proof_input(input_dir: &str, args: &Args) -> Result<BlockExecInput, Box<dyn Error>> {
    let header_json = fs::read_to_string(format!("{input_dir}/header.json"))?;
    let header: Header = serde_json::from_str(&header_json)?;
    let header_raw = serde_cbor::to_vec(&header)?;

    let dah_json = fs::read_to_string(format!("{input_dir}/dah.json"))?;
    let dah: DataAvailabilityHeader = serde_json::from_str(&dah_json)?;

    let blobs_json = fs::read_to_string(format!("{input_dir}/blobs.json"))?;
    let blobs: Vec<Blob> = serde_json::from_str(&blobs_json)?;
    let blobs_raw = serde_cbor::to_vec(&blobs)?;

    let pub_key_encoded = fs::read(format!("{input_dir}/pub_key.bin"))?;
    let pub_key = bincode::deserialize(&pub_key_encoded)?;

    let namespace_hex = env::var("CELESTIA_NAMESPACE").expect("CELESTIA_NAMESPACE env variable must be set");
    let namespace = Namespace::new_v0(&hex::decode(namespace_hex)?)?;

    let proofs_encoded = fs::read(format!("{input_dir}/namespace_proofs.bin"))?;
    let proofs: Vec<NamespaceProof> = bincode::deserialize(&proofs_encoded)?;

    let executor_inputs_encoded = fs::read(format!("{input_dir}/executor_inputs.bin"))?;
    let executor_inputs: Vec<EthClientExecutorInput> = bincode::deserialize(&executor_inputs_encoded)?;

    // Determine trusted height
    let trusted_height = if let Some(h) = args.trusted_height {
        h
    } else if let Some(input) = executor_inputs.first() {
        input.parent_header().number
    } else {
        panic!("Trusted height not provided and executor_inputs is empty");
    };

    // Determine trusted root
    let trusted_root = if let Some(root_str) = args.trusted_root.as_deref() {
        let bytes = hex::decode(root_str).expect("Invalid hex");
        let array: [u8; 32] = bytes.try_into().expect("Trusted root must be 32 bytes");
        FixedBytes::from(array)
    } else if let Some(input) = executor_inputs.first() {
        input.state_anchor()
    } else {
        panic!("Trusted root not provided and executor_inputs is empty");
    };

    let input = BlockExecInput {
        header_raw,
        dah,
        blobs_raw,
        pub_key,
        namespace,
        proofs,
        executor_inputs: executor_inputs.clone(),
        trusted_height,
        trusted_root,
    };

    Ok(input)
}
